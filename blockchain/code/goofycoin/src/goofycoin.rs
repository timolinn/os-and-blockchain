//! This is the implementation of GoofyCoin
//!
//! GoofyCoin is a simple but insecure cryptocurrency implementation
//! It's insecure because it fails to solve the `double-spending attack`
//!
//! Here's How it works:
//!
//! 1. A coin is generated by goofy, who signs the coin with his
//! public key (public identity).
//! 2. This coin is reprensented by a unique identity.
//! 3. It can be spent by making a "statement" and generating a hash
//! pointer that points to the coin and signed by goofy's PK
use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;
use openssl::sha::sha256;
use nanoid::simple;

pub struct GoofyCoin {
    unique_id: String,
    signed: String,
    owner: Person
}

#[derive(Copy, Clone)]
pub struct Person {
    name: &'static str,
    pk: [u8; 32],
    sk: [u8; 32]
}

impl Person {
    pub fn new(name: &'static str) -> Person {
        Person {
            name,
            pk: sha256(random_value().as_bytes()),
            sk: sha256(random_value().as_bytes())
        }
    }

    pub fn sign(&mut self) -> String {
        let sig = String::from("signature");
        sig
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn public_key(&self) -> String {
        hex::encode(self.pk)
    }

    pub fn secret_key(&self) -> String {
        hex::encode(self.sk)
    }
}

fn random_value() -> String {
    let rand_string: String = thread_rng()
        .sample_iter(&Alphanumeric)
        .take(30)
        .collect();

    rand_string
}

impl GoofyCoin {
    pub fn new() -> GoofyCoin {
        let mut goofy = Person::new("goofy");
        GoofyCoin {
            unique_id: simple(),
            owner: goofy,
            signed: goofy.sign()
        }
    }
}