//! This is the implementation of GoofyCoin
//!
//! GoofyCoin is a simple but insecure cryptocurrency implementation
//! It's insecure because it fails to solve the `double-spending attack`
//!
//! Here's How it works:
//!
//! 1. A coin is generated by goofy, who signs the coin with his
//! public key (public identity).
//! 2. This coin is reprensented by a unique identity.
//! 3. It can be spent by making a "statement" and generating a hash
//! pointer that points to the coin and signed by goofy's PK
#![allow(unused)]
use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;
use openssl::sha::sha256;
use openssl::{ec, ecdsa, nid};
use openssl::sign::{Signer, Verifier};
use openssl::pkey::{Private, Public};
use nanoid::simple;

#[derive(Clone)]
pub struct Person {
    pub name: &'static str,
    pub pk: ec::EcKey<Public>,
    sk: ec::EcKey<Private>
}

impl Person {
    pub fn new(name: &'static str) -> Person {
        // generating private and public key
        // https://docs.rs/openssl/0.10.29/src/openssl/ecdsa.rs.html#174
        let group = ec::EcGroup::from_curve_name(nid::Nid::X9_62_PRIME192V1).unwrap();
        println!("{}", nid::Nid::X9_62_PRIME192V1.as_raw());
        let private_key = ec::EcKey::generate(&group).unwrap();
        let public_key_point = private_key.public_key();

        Person {
            name,
            pk: ec::EcKey::from_public_key(&group, public_key_point).unwrap(),
            sk: private_key
        }
    }

    pub fn sign(&self, data: String) -> ecdsa::EcdsaSig {
        ecdsa::EcdsaSig::sign(data.as_bytes(), &self.sk).unwrap()
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    // pub fn public_key(&self) -> String {
    //     hex::encode(self.pk)
    // }
}

fn random_value() -> String {
    let rand_string: String = thread_rng()
        .sample_iter(&Alphanumeric)
        .take(32)
        .collect();

    rand_string
}


pub struct GoofyCoin {
    unique_id: String,
    pub signed: ecdsa::EcdsaSig,
    owner: Person
}

impl GoofyCoin {
    pub fn new(goofy: Person) -> GoofyCoin {
        let uid = simple();
        GoofyCoin {
            unique_id: uid.clone(),
            owner: goofy.clone(),
            signed: goofy.sign(uid)
        }
    }
}