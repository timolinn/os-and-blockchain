//! This is the implementation of GoofyCoin
//!
//! GoofyCoin is a simple but insecure cryptocurrency implementation
//! It's insecure because it fails to solve the `double-spending attack`
//!
//! Here's How it works:
//!
//! 1. A coin is generated by goofy, who signs the coin with his
//! public key (public identity).
//! 2. This coin is reprensented by a unique identity.
//! 3. It can be spent by making a "statement" and generating a hash
//! pointer that points to the coin and signed by goofy's PK
#![allow(unused)]
use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;
use openssl::sha::sha256;
use openssl::{ec, ecdsa, nid};
use openssl::sign::{Signer, Verifier};
use openssl::pkey::{Private, Public};
use nanoid::simple;
use std::{time, thread};

#[derive(Clone, Debug)]
pub struct Person {
    pub name: &'static str,
    pub pk: ec::EcKey<Public>,
    sk: ec::EcKey<Private>
}

impl Person {
    pub fn new(name: &'static str) -> Person {
        // generating private and public key
        // https://docs.rs/openssl/0.10.29/src/openssl/ecdsa.rs.html#174
        let group = ec::EcGroup::from_curve_name(nid::Nid::X9_62_PRIME192V1).unwrap();
        let private_key = ec::EcKey::generate(&group).unwrap();
        let public_key_point = private_key.public_key();

        Person {
            name,
            pk: ec::EcKey::from_public_key(&group, public_key_point).unwrap(),
            sk: private_key
        }
    }

    pub fn sign(&self, data: String) -> ecdsa::EcdsaSig {
        ecdsa::EcdsaSig::sign(data.as_bytes(), &self.sk).unwrap()
    }

    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn transfer_coin(&self, mut coin: GoofyCoin, p: &Person) -> Result<GoofyCoin, String> {
        if (coin.verify(&self)) {
            println!("Transferring coin ownership to {}...", p.name());
            thread::sleep(time::Duration::from_millis(3000));
            coin.signed = p.sign(coin.unique_id.clone());
            coin.owner = p.clone();
            println!("Coin transferred to {}", p.name());
            return Ok(coin);
        }
        Err(String::from("failed to transfer coin"))
    }
}

fn random_value() -> String {
    let rand_string: String = thread_rng()
        .sample_iter(&Alphanumeric)
        .take(32)
        .collect();

    rand_string
}


pub struct GoofyCoin {
    pub unique_id: String,
    pub signed: ecdsa::EcdsaSig,
    owner: Person
}

impl GoofyCoin {
    pub fn new(goofy: Person) -> GoofyCoin {
        let uid = simple();
        GoofyCoin {
            unique_id: uid.clone(),
            owner: goofy.clone(),
            signed: goofy.sign(uid)
        }
    }

    pub fn signature(&self) -> String {
        hex::encode(self.signed.to_der().unwrap())
    }

    pub fn verify(&self, p: &Person) -> bool {
        self.signed.verify(self.unique_id.as_bytes(), &p.pk).unwrap()
    }

    pub fn owner(&self) -> &Person {
        &self.owner
    }
}